

12-3 自定义泛型结构
     自定义泛型类
     自定义泛型接口
     自定义泛型方法



    4.自定义泛型结构：泛型方法   与所属的类或接口是不是泛型的没有关系

                    泛型方法的*泛型标识*写在方法返回类型前，不必在类名前写泛型标识
                    类名后写泛型标识的为泛型类

                    泛型方法和带泛型的方法不是一回事     区别：泛型方法的返回类型前会有一个  <泛型标识>
                        泛型方法是有明确的定义格式的，而带泛型的方法仅仅是用到了泛型而已

                        经典：静态的方法不能使用类的泛型，但是静态方法可以定义成泛型的
                        原因：类的泛型在实例化时才确定类型，而静态方法随着类的加载而加载，在加载时就要确定类型
                            但：静态的泛型方法特许在调用时才确定类型


                     方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型
                        方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。

                     泛型方法的格式：
                        [访问权限] <泛型> 返回类型 方法名([泛型标识 参数名称]) 抛出的异常

                     泛型方法声明泛型时也可以指定上限(在12.5中讲)
                        public class DAO {
                            public <E> E get(int id, E e) {
                                E result = null;
                                return result;
                            }
                        }

    1.泛型的声明
        interface List<T> 和 class GenTest<K,V>
            其中，T,K,V不代表值，而是表示类型。这里使用任意字母都可以。
            常用T表示，是Type的缩写。

    2.泛型的实例化：
        一定要在类名后面指定类型参数的值（类型）。如：
            List<String> strList = new ArrayList<String>();
            Iterator<Customer> iterator = customers.iterator();
         T 只能 是*类*（数组也可以），不能用基本数据类型填充。但可以使用包装类填充
         把一个集合中的内容限制为一个特定的数据类型，这就是generics背后
            的核心思想

    3.自定义泛型结构：泛型类、泛型接口
        1. 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：
            <E1,E2,E3>
        2. 泛型类的构造器如下：public GenericClass(){}。//构造器不能跟泛型，因为构造器是没类型的
            而下面是错误的：public GenericClass<E>(){}
        3. 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。
        4. 泛型不同的引用不能相互赋值。
            >尽管在编译时ArrayList<String>和ArrayList<Integer>是两种类型，但是，在运行时只有
                一个ArrayList被加载到JVM中。
        5. 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价
            于Object。经验：泛型要使用一路都用。要不用，一路都不要用。
        6. 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。
        7. jdk1.7，泛型的简化操作：ArrayList<Fruit> flist = new ArrayList<>();
        8. 泛型的指定中不能使用基本数据类型，可以使用包装类替换。

        /////  9是一个难点
        9. 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态
            属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法
            中不能使用 *类的泛型* 。（注：类的泛型是在实例化时确定类型，而static是在类加载时而加载）

            静态方法中不能使用*类的泛型*。     因为类的泛型是在实例化时确定类型，而static修饰的结构是在类加载时而加载
                    上述此时的静态方法并不是泛型方法，在类加载时就需要确定类型
                    而静态的泛型方法特许许在调用时才确定类型

                    泛型方法：<泛型标识>  写在方法返回值类型前
                    泛型类：<泛型标识>  写在类名后

                    但是静态方法可以声明为泛型的，因为泛型方法是在调用时确定类型的

                    总结：一个方法是不是泛型方法，与类的泛型没有任何关系




        10. 异常类不能是泛型的
        11. 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity];
            参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。
        12.父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：
             子类不保留父类的泛型：按需实现
                 没有类型 （擦除）
                 具体类型
             子类保留父类的泛型：泛型子类
                 全部保留
                 部分保留
            结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自
                己的泛型

            示例代码：
                class Father<T1, T2> {
                }

                // 子类不保留父类的泛型
                // 1)没有类型 （擦除）
                class Son1 extends Father {// 等价于class Son extends Father<Object,Object>{
                }

                // 2)具体类型
                class Son2 extends Father<Integer, String> {//父类已经指明的泛型类型，子类不再保留泛型标识
                }

                // 子类保留父类的泛型
                // 1)全部保留
                class Son3<T1, T2> extends Father<T1, T2> {
                }

                // 2)部分保留
                class Son4<T2> extends Father<Integer, T2> {
                }


                //////////////  子类增加了自己的泛型   ////////////
                class Father<T1, T2> {
                }

                // 子类不保留父类的泛型
                // 1)没有类型 擦除
                class Son<A, B> extends Father{//等价于class Son extends Father<Object,Object>{
                }//A,B为子类增加的泛型

                // 2)具体类型
                class Son2<A, B> extends Father<Integer, String> {
                }

                // 子类保留父类的泛型
                // 1)全部保留
                class Son3<T1, T2, A, B> extends Father<T1, T2> {
                }

                // 2)部分保留
                class Son4<T2, A, B> extends Father<Integer, T2> {
                }

